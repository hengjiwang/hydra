#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
sys.path.insert(0, '/home/hengji/Documents/hydra_calcium_model/single/')

import numpy as np
import matplotlib.pyplot as plt
import time
from scipy.integrate import odeint
from scipy.sparse import spdiags
import pandas as pd
from numba import jit, int32, float64
from multiprocessing import Pool

num = 5

onex = np.ones(num)
Dx = spdiags(np.array([onex,-2*onex,onex]), np.array([-1,0,1]),num,num).toarray()
Dx[0,0] = -1
Dx[num-1,num-1] = -1 
Ix = np.eye(num)
L = np.kron(Dx, Ix) + np.kron(Ix, Dx)
        
# General parameters
gc = 5e4
g_ip3 = 1

# Hofer parameters
k1 = 0.0004
k2 = 0.2
ka = 0.2
kip = 0.3
k3 = 0.5
v40 = 0.025
v41 = 0.2
kr = 1
k5 = 0.5
k6 = 4
ki = 0.2
kg = 0.1 # unknown
a0 = 1 # 1e-3 - 10
v7 = 0 # 0 - 0.05
v8 = 4e-4
kca = 0.3
k9 = 0.01
beta = 20

c0 = 0.05
s0 = 600
r0 = 0.94
ip0 = 0.01

# Fast Parameters
c_m = 1e-6 # [F/cm^2]
A_cyt = 4e-5 # [cm^2]
V_cyt = 6e-9 # [cm^3]
d = 10e-4 # 10e-4 # [cm]
F = 96485332.9 # [mA*s/mol]
v0 = -50 # (-40 to -60)
n0 = 0
hv0 = 0
hc0 = 0
x0 = 0
z0 = 0
p0 = 0
q0 = 0
bx0 = 0
cx0 = 0

# Fluorescence Parameters
r_inc = 200
k1p = 2.5
k1n = 0.1
k2p = 16.9
k2n = 205
k3p = 1.1
k3n = 11.8
k4p = 1069
k4n = 5.8
g0 = 3.281
c1g0 = 4.101
c2g0 = 0.017
c3g0 = 0
c4g0 = 0.0007
phi0 = 1
phi1 = 1
phi2 = 1
phi3 = 1
phi4 = 81

g_cal = 0.0005 # [S/cm^2] 
e_cal = 51
k_cal = 1 # [uM]
g_cat = 0.003 # 0.0003
e_cat = 51
g_kcnq = 0 # 0.0001 # [S/cm^2]
e_k = -75 

g_kv = 0 # 0.0004
g_kca =  10e-9 / A_cyt # 45.7e-9 / A_cyt
g_bk = 0
e_bk = -55

num2 = num ** 2

scale_stim_v = 0.01
scale_stim_ip = 1.0

# Time
T = 300
dt = 0.001
t_time = np.linspace(0, T, int(T/dt))

'''Hofer methods'''
@jit(nopython=True)
def i_rel(c, s, ip, r):
    # Release from ER, including IP3R and leak term [uM/s]
    return (k2 * r * c**2 * ip**2 / (ka**2 + c**2) / (kip**2 + ip**2)) * (s - c)

@jit(nopython=True)
def i_serca(c):
    # SERCA [uM/s]
    return k3 * c

@jit(nopython=True)
def i_leak(c, s):
    k1 = (i_serca(c0) - i_rel(c0, s0, ip0, r0)) / (s0 - c0)
    return k1 * (s - c)

@jit(nopython=True)
def i_in(ip):
    return 1e9 * (i_cal(v0, n0, hv0, hc0) + \
    i_cat(v0, bx0, cx0)) / (2 * F * d) + i_out(c0) + \
    v41 * ip**2 / (kr**2 + ip**2) - v41 * ip0**2 / (kr**2 + ip0**2)

@jit(nopython=True)
def i_out(c):
    # Additional eflux [uM/s]
    return k5 * c

@jit(nopython=True)
def v_r(c, r):
    # Rates of receptor inactivation and recovery [1/s]
    return k6 * (ki**2 / (ki**2 + c**2) - r)

@jit(nopython=True)
def i_plcb(v8):
    # Agonist-controlled PLC-beta activity [uM/s]
    return v8 * 1 / ((1 + kg)*(kg/(1+kg) + a0)) * a0

@jit(nopython=True)
def i_plcd(c):
    # PLC-delta activity [uM/s]
    return v7 * c**2 / (kca**2 + c**2)

@jit(nopython=True)
def i_deg(ip):
    # IP3 degradion [uM/s]
    return k9 * ip

@jit(nopython=True)
def stim(t, stims):
    # Stimulation

    condition = False

    for stim_t in stims:
        condition = condition or stim_t <= t < stim_t + 4

    if condition:
        return 1
    else:
        return 0

'''Fast methods'''
@jit(nopython=True)
def i_cal(v, n, hv, hc):
    # L-type calcium channel [mA/cm^2]
    return g_cal * n**2 * hv * hc * (v - e_cal)

@jit(nopython=True)
def n_inf(v):
    # [-]
    return 1 / (1 + np.exp(-(v+9)/8))

@jit(nopython=True)
def hv_inf(v):
    # [-]
    return 1 / (1 + np.exp((v+30)/13))

@jit(nopython=True)
def hc_inf(c):
    # [-]
    return k_cal / (k_cal + c)

@jit(nopython=True)
def tau_n(v):
    # [s]
    return 0.000001 / (1 + np.exp(-(v+22)/308))

@jit(nopython=True)
def tau_hv(v):
    # [s]
    return 0.09 * (1 - 1 / ((1 + np.exp((v+14)/45)) * (1 + np.exp(-(v+9.8)/3.39))))

@jit(nopython=True)
def tau_hc():
    # [s]
    return 0.02

@jit(nopython=True)
def i_cat(v, bx, cx):
    return g_cat * bx**2 * cx * (v - e_cat)

@jit(nopython=True)
def bx_inf(v):
    return 1 / (1 + np.exp(-(v+32.1)/6.9))

@jit(nopython=True)
def cx_inf(v):
    return 1 / (1 + np.exp((v+63.8)/5.3))

@jit(nopython=True)
def tau_bx(v):
    return 0.00045 + 0.0039 / (1 + ((v+66)/26)**2)

@jit(nopython=True)
def tau_cx(v):
    return 0.15 - 0.15 / ((1 + np.exp((v-417.43)/203.18))*(1 + np.exp(-(v+61.11)/8.07)))

@jit(nopython=True)
def i_kcnq(v, x, z):
    # KCNQ1 channel [mA/cm^2]
    return g_kcnq * x**2 * z * (v - e_k)

@jit(nopython=True)
def x_inf(v):
    # [-]
    return 1 / (1 + np.exp(-(v+7.1)/15))

@jit(nopython=True)
def z_inf(v):
    # [-]
    return 0.55 / (1 + np.exp((v+55)/9)) + 0.45

@jit(nopython=True)
def tau_x(v):
    # [s]
    return 0.001 / (1 + np.exp((v+15)/20))

@jit(nopython=True)
def tau_z(v):
    # [s]
    return 0.01 * (200 + 10 / (1 + 2 * ((v+56)/120)**5))

@jit(nopython=True)
def i_kv(v, p, q):
    return g_kv * p * q * (v - e_k)

@jit(nopython=True)
def p_inf(v):
    return 1 / (1 + np.exp(-(v+1.1)/11))

@jit(nopython=True)
def q_inf(v):
    return 1 / (1 + np.exp((v+58)/15))

@jit(nopython=True)
def tau_p(v):
    return 0.001 / (1 + np.exp((v+15)/20))

@jit(nopython=True)
def tau_q(v):
    return 0.4 * (200 + 10 / (1 + 2*((v+54.18)/120)**5))

@jit(nopython=True)
def i_kca(v, c):
    return g_kca * 1 / (1 + np.exp(v/(-17) - 2 * np.log(c))) * (v - e_k)
    # return 5 * g_kca * c**2 / (c**2 + 5**2) * (v - e_k)

@jit(nopython=True,parallel=True)
def i_bk(v):
    # Background voltage leak [mA/cm^2]
    g_bk = - (i_cal(v0, n0, hv0, hc0) \
    + i_cat(v0, bx0, cx0) \
    + i_kca(v0, c0))/(v0 - e_bk)
    return g_bk * (v - e_bk)

@jit(nopython=True)
def stim_v(t, stims):

    condition = False

    for stim_t in stims:
        condition = condition or stim_t <= t < stim_t + 0.01

    if condition:
        return 1
    else:
        return 0

'''Fluorescence methods'''
@jit(nopython=True,parallel=True)
def f_total(g, c1g, c2g, c3g, c4g):
    f_cyt = phi0*g + phi1*c1g + phi2*c2g + \
    phi3*c3g + phi4*c4g
    f_cyt0 = phi0*g0 + phi1*c1g0 + \
    phi2*c2g0 + phi3*c3g0 + phi4*c4g0
    f_bg = f_cyt0 * 2.5
    return (f_cyt + f_bg) / (f_cyt0 + f_bg)

@jit(nopython=True)
def r_1(c, g, c1g):
    return k1p * c * g - k1n * c1g

@jit(nopython=True)
def r_2(c, c1g, c2g):
    return k2p * c * c1g - k2n * c2g

@jit(nopython=True)
def r_3(c, c2g, c3g):
    return k3p * c * c2g - k3n * c3g

@jit(nopython=True)
def r_4(c, c3g, c4g):
    return k4p * c * c3g - k4n * c4g

'''Time stepping'''
@jit(nopython=True,parallel=True)
def rhs(y, t, stims_v, stims_ip):
    # Right-hand side formulation

    # Assign variables
    c, s, r, ip, v, n, hv, hc, bx, cx, g, c1g, c2g, c3g, c4g = (y[0:num2], 
    y[num2:2*num2], y[2*num2:3*num2], y[3*num2:4*num2], y[4*num2:5*num2], 
    y[5*num2:6*num2], y[6*num2:7*num2], y[7*num2:8*num2], y[8*num2:9*num2], 
    y[9*num2:10*num2], y[10*num2:11*num2], y[11*num2:12*num2], y[12*num2:13*num2],
    y[13*num2:14*num2], y[14*num2:15*num2])

    # Current terms which will be used for multiple times
    
    irel = i_rel(c, s, ip, r)
    ileak = i_leak(c, s)
    iserca = i_serca(c)
    iin = i_in(ip)
    iout = i_out(c)
    ical = i_cal(v, n, hv, hc)
    icat = i_cat(v, bx, cx)
    iplcb_stim = scale_stim_ip * i_plcb(stim(t, stims_ip))
    iplcb_rest = i_plcb(v8)
    ir1 = r_1(c, g, c1g)
    ir2 = r_2(c, c1g, c2g)
    ir3 = r_3(c, c2g, c3g)
    ir4 = r_4(c, c3g, c4g)

    dcdt = irel + ileak - iserca + iin - iout - 1e9 * (ical + icat) / (2 * F * d) \
        - ir1 - ir2 - ir3 - ir4
    dsdt = beta * (iserca - irel - ileak)
    drdt = v_r(c, r)
    dipdt = iplcb_rest + i_plcd(c) - i_deg(ip) + g_ip3 * L@ip
    dipdt[-int(num/2)-1         : -int(num/2) + 2        ] += iplcb_stim - iplcb_rest
    dipdt[-int(num/2)-1 -   num : -int(num/2) + 2 -   num] += iplcb_stim - iplcb_rest
    dipdt[-int(num/2)-1 - 2*num : -int(num/2) + 2 - 2*num] += iplcb_stim - iplcb_rest
    dvdt = - 1 / c_m * (ical + icat + i_kca(v, c) + i_bk(v)) \
        + gc * L@v
    dvdt[0:3*num] += 1 / c_m * scale_stim_v * stim_v(t, stims_v)
    dndt = (n_inf(v) - n)/tau_n(v)
    dhvdt = (hv_inf(v) - hv)/tau_hv(v)
    dhcdt = (hc_inf(c) - hc)/tau_hc()
    dbxdt = (bx_inf(v) - bx)/tau_bx(v)
    dcxdt = (cx_inf(v) - cx)/tau_cx(v)
    dgdt = - ir1
    dc1gdt = (ir1 - ir2)
    dc2gdt = (ir2 - ir3)
    dc3gdt = (ir3 - ir4)
    dc4gdt = ir4

    dydt = np.concatenate((dcdt, dsdt, drdt, dipdt, dvdt, dndt, dhvdt, dhcdt, dbxdt, dcxdt, dgdt, dc1gdt, dc2gdt, dc3gdt, dc4gdt))  

    return dydt

def step(stims_v = [201,203,205,207,209,211,213,215,217,219], stims_ip = [10]):
    # Time stepping

    start_time = time.time() # Begin counting time

    global r0
    global n0
    global hv0
    global hc0
    global bx0
    global cx0
    global v8

    r0 =  ki**2 / (ki**2 + c0**2)
    n0 = n_inf(v0)
    hv0 = hv_inf(v0)
    hc0 = hc_inf(c0)
    bx0 = bx_inf(v0)
    cx0 = cx_inf(v0)
    v8 = (i_deg(ip0) - i_plcd(c0)) / (1 / ((1 + kg)*(kg/(1+kg) + a0)) * a0)

    base_mat = np.ones((num,num))

    inits = [c0, s0, r0, ip0, v0, n0, hv0, 
    hc0, bx0, cx0, g0, c1g0, c2g0, c3g0, c4g0]

    y0 = np.array([x*base_mat for x in inits])

    y0 = np.reshape(y0, 15*num2)   

    sol = odeint(rhs, y0, t_time, args = (np.array(stims_v), np.array(stims_ip)), hmax = 0.005)

    elapsed = (time.time() - start_time) # End counting time
    print("Time used:",elapsed)

    return sol

if __name__ == '__main__':
    n_cel = num
    sol = step()
    df = pd.DataFrame(sol[:,0:n_cel*n_cel])
    # df.to_csv('../save/data/c_5x5_300s_withjit.csv', index = False)