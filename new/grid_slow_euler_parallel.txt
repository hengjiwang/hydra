#!/usr/bin/env python
# -*- coding: utf-8 -*-

import numpy as np
import pandas as pd
import scipy
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from scipy.sparse import spdiags
from slow_cell import SlowCell
import time
from fluo_encoder import FluoEncoder
from tqdm.auto import tqdm
from multiprocessing import Pool

iipr = None
ileak = None
iserca = None
iin = None
ipmca = None
vr = None
ideg = None
iplcb_base = None
iplcb_stim = None
iplcd = None
ir1 = None
ir2 = None
ir3 = None
ir4 = None

class Grid(SlowCell, FluoEncoder):
    '''A 1D cell chain with cells connected through gap junctions'''
    def __init__(self, numx=20, numy=40, T=200, dt = 0.001, k2 = 0.2, s0 = 600, v7 = 0.03, k9 = 0.06):
        # Parameters
        FluoEncoder.__init__(self, T, dt)
        SlowCell.__init__(self, T, dt)
        self.g_ip3x = 0.1
        self.g_ip3y = 1
        self.numx = numx
        self.numy = numy
        onex = np.ones(self.numx)
        Ix = np.eye(numx)
        oney = np.ones(self.numy)
        Iy = np.eye(numy)
        Dx = spdiags(np.array([onex,-2*onex,onex]),np.array([-1,0,1]),self.numx,self.numx).toarray()
        Dy = spdiags(np.array([oney,-2*oney,oney]),np.array([-1,0,1]),self.numy,self.numy).toarray()
        Dx[0, self.numx-1] = 1
        Dx[self.numx-1, 0] = 1
        Dy[0,0] = -1
        Dy[self.numy-1,self.numy-1] = -1 
        Dx = scipy.sparse.csr_matrix(Dx)
        Dy = scipy.sparse.csr_matrix(Dy)
        Ix = scipy.sparse.csr_matrix(Ix)
        Iy = scipy.sparse.csr_matrix(Iy)
        self.Lip3 = self.g_ip3x * scipy.sparse.kron(Dx, Iy) + self.g_ip3y * scipy.sparse.kron(Ix, Dy)
        # self.Lip3 = self.g_ip3x * np.kron(Dx, Iy) + self.g_ip3y * np.kron(Ix, Dy)
        # plt.figure()
        # plt.imshow(self.Lip3.toarray(), 'rainbow')
        # plt.colorbar()
        # plt.show()
        self.k9 = k9
        self.v7 = v7
        self.k2 = k2
        self.s0 = s0

        self.T = T
        self.dt = dt
        self.time = np.linspace(0, T, int(T/dt))

        # Build grid
        self.num2 = self.numx * self.numy

    def i_ipr(self, c, s, ip, r):
        # Release from ER, including IP3R and leak term [uM/s]
        global iipr
        iipr = (self.k2 * r * c**2 * ip**2 / (self.ka**2 + c**2) / (self.kip**2 + ip**2)) * (s - c)
        return iipr

    def i_serca(self, c):
        # SERCA [uM/s]
        global iserca
        iserca = self.k3 * c
        return iserca

    def i_leak(self, c, s):
        global ileak
        k1 = (self.i_serca(self.c0) - self.i_ipr(self.c0, self.s0, self.ip0, self.r0)) / (self.s0 - self.c0)
        ileak = k1 * (s - c)
        return ileak

    def i_pmca(self, c):
        # Additional eflux [uM/s]
        global ipmca
        ipmca = self.k5 * c
        return ipmca

    def i_in(self, ip):
        # Calcium entry rate [uM/s]
        global iin
        iin = self.i_pmca(self.c0) + self.v41 * ip**2 / (self.kr**2 + ip**2) - self.v41 * self.ip0**2 / (self.kr**2 + self.ip0**2)
        return iin

    '''IP3R terms'''
    def v_r(self, c, r):
        # Rates of receptor inactivation and recovery [1/s]
        global vr
        vr = self.k6 * (self.ki**2 / (self.ki**2 + c**2) - r)
        return vr

    '''IP3 terms'''
    def i_plcb(self, v8):
        # Agonist-controlled PLC-beta activity [uM/s]
        
        return v8 * 1 / ((1 + self.kg)*(self.kg/(1+self.kg) + self.a0)) * self.a0

    def i_plcd(self, c):
        # PLC-delta activity [uM/s]
        global iplcd
        iplcd = self.v7 * c**2 / (self.kca**2 + c**2)
        return iplcd

    def i_deg(self, ip):
        # IP3 degradion [uM/s]
        global ideg
        ideg = self.k9 * ip
        return ideg

    def r_1(self, c, g, c1g):
        global ir1
        ir1 = self.k1p * c * g - self.k1n * c1g
        return ir1
    
    # rate 2
    def r_2(self, c, c1g, c2g):
        global ir2
        ir2 = self.k2p * c * c1g - self.k2n * c2g
        return ir2
    
    # rate_3
    def r_3(self, c, c2g, c3g):
        global ir3
        ir3 = self.k3p * c * c2g - self.k3n * c3g
        return ir3
    
    # rate_4
    def r_4(self, c, c3g, c4g):
        global ir4
        ir4 = self.k4p * c * c3g - self.k4n * c4g
        return ir4
    
    def rhs(self, y, t, stims_v, stims_ip):
        # Right-hand side formulation

        numx = self.numx
        numy = self.numy
        num2 = self.num2

        c, s, r, ip, g, c1g, c2g, c3g, c4g = (y[0:num2], 
        y[num2:2*num2], y[2*num2:3*num2], y[3*num2:4*num2], y[4*num2:5*num2], 
        y[5*num2:6*num2], y[6*num2:7*num2], y[7*num2:8*num2], y[8*num2:9*num2])

        ip_stim = self.stim(t, stims_ip)

        global iipr 
        global ileak 
        global iserca 
        global iin 
        global ipmca 
        global vr 
        global ideg 
        global iplcb_base 
        global iplcb_stim 
        global iplcd 
        global ir1 
        global ir2 
        global ir3 
        global ir4 

        p = Pool(10)
        # Current terms which will be used for multiple times
        iipr = p.apply_async(self.i_ipr, args = (c, s, ip, r))
        ileak = p.apply_async(self.i_leak, args = (c, s))
        iserca = p.apply_async(self.i_serca, args = (c, ))
        iin = p.apply_async(self.i_in, args = (ip, ))
        ipmca = p.apply_async(self.i_pmca, args = (c, ))
        vr = p.apply_async(self.v_r, args = (c, r))
        ideg = p.apply_async(self.i_deg, args = (ip, ))
        iplcd = p.apply_async(self.i_plcd, args = (c, ))
        ir1 = p.apply_async(self.r_1, args = (c, g, c1g))
        ir2 = p.apply_async(self.r_2, args = (c, c1g, c2g))
        ir3 = p.apply_async(self.r_3, args = (c, c2g, c3g))
        ir4 = p.apply_async(self.r_4, args = (c, c3g, c4g))
        p.close()
        p.join()

        iipr = iipr.get()
        ileak = ileak.get()
        iserca = iserca.get()
        iin = iin.get()
        ipmca = ipmca.get()
        vr = vr.get()
        ideg = ideg.get()
        iplcd = iplcd.get()
        ir1 = ir1.get()
        ir2 = ir2.get()
        ir3 = ir3.get()
        ir4 = ir4.get()

        global iplcb_base
        global iplcb_stim

        iplcb_base = self.i_plcb(self.v8)
        iplcb_stim = self.i_plcb(self.stim(t, stims_ip))   

        dcdt =  (iipr +ileak - iserca) + (iin - ipmca) - ir1 - ir2 - ir3 - ir4
        dsdt = self.beta * (iserca - iipr - ileak)
        drdt = vr
        dipdt = iplcb_base + iplcd - ideg + self.Lip3.dot(ip)

        dipdt[[(int(numx/2)-j)*numy for j in range(-5, 5)]] += iplcb_stim - iplcb_base

        dgdt = - ir1
        dc1gdt = ir1 - ir2
        dc2gdt = ir2 - ir3
        dc3gdt = ir3 - ir4
        dc4gdt = ir4

        deriv = np.array([dcdt, dsdt, drdt, dipdt, dgdt, dc1gdt, dc2gdt, dc3gdt, dc4gdt])

        dydt = np.reshape(deriv, 9*num2)

        return dydt

    def step(self, stims_v = [201,203,205,207,209,211,213,215,217,219], stims_ip = [10]):
        # Time stepping
        self.v8 = (self.i_deg(self.ip0) - self.i_plcd(self.c0)) / (1 / ((1 + self.kg)*(self.kg/(1+self.kg) + self.a0)) * self.a0)

        base_mat = np.ones((self.numy, self.numx))
        inits = [self.c0, self.s0, self.r0, self.ip0, self.g0, self.c1g0, self.c2g0, self.c3g0, self.c4g0]
        y0 = np.array([x*base_mat for x in inits])
        y0 = np.reshape(y0, 9*self.num2)  

        start_time = time.time() # Begin counting time
        
        y = y0
        T = self.T
        dt = self.dt

        sol = np.zeros((int(T/dt/50), 9*self.num2))

        for j in tqdm(np.arange(0, int(T/dt))):
            t = j*dt
            dydt = self.rhs(y, t, stims_v, stims_ip)
            y += dydt * dt
            if j%50 == 0: sol[int(j/50), :] = y


        elapsed = (time.time() - start_time) # End counting time
        print("Num: " + str(self.numx) + ',' + str(self.numy) + "; Time used:" + str(elapsed))

        return sol

    def plot(self, a, tmin=0, tmax=100, xlabel = 'time[s]', ylabel = None, color = 'b'):
        x = np.linspace(tmin, tmax, len(a))
        plt.plot(x, a[int(tmin/self.dt):int(tmax/self.dt)], color)
        # plt.plot(self.time[int(tmin/self.dt):int(tmax/self.dt)], a[int(tmin/self.dt):int(tmax/self.dt)], color)
        if xlabel:  plt.xlabel(xlabel)
        if ylabel:  plt.ylabel(ylabel)

if __name__ == "__main__":
    model = Grid(numx=200, numy=200, T=100, dt=0.0004)
    sol = model.step()
    df = pd.DataFrame(sol[:,0:model.numx*model.numy])
    df.to_csv('c_200x200_100s_slow.csv', index = False)